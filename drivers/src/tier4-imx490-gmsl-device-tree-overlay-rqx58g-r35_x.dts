/dts-v1/;
/plugin/;

/ {
    overlay-name = "TIERIV IMX490 GMSL2 Camera Device Tree Overlay";
    compatible = "nvidia,p2822-0000+p2888-0001";
    jetson-header-name = "Jetson AGX CSI Connector";

    fragment@0 {
        target = <&mux_i2c_0>;
        __overlay__ {
            i2c-mux,deselect-on-exit;
            #address-cells = <1>;
            #size-cells = <0>;

            ser_prim: max9295_prim@62 { 
                status = "okay";
                compatible = "nvidia,tier4_max9295";
                reg = <0x62>;
                is-prim-ser;
            };
            ser_a: max9295_a@42 {
                status = "okay";
                compatible = "nvidia,tier4_max9295";
                reg = <0x42>;
                nvidia,gmsl-dser-device = <&dser_0>;
                prim-parent = <&ser_prim>;
            };
            ser_b: max9295_b@60 {
                status = "okay";
                compatible = "nvidia,tier4_max9295";
                reg = <0x60>;
                nvidia,gmsl-dser-device = <&dser_0>;
                prim-parent = <&ser_prim>;
            };
            isp_prim: gw5300_prim@6d {
                compatible = "nvidia,tier4_gw5300";
                reg = <0x6d>;
                is-prim-isp;
            };
            isp_a: gw5300_a@6e {
                compatible = "nvidia,tier4_gw5300";
                reg = <0x6e>;
            };
            isp_b: gw5300_b@6f {
                compatible = "nvidia,tier4_gw5300";
                reg = <0x6f>;
            };

            imx490_b@2c {
                status = "okay";
                def-addr = <0x1a>;
                /* Define any required hw resources needed by driver */
                /* ie. clocks, io pins, power sources */
            //  clocks = <&bpmp_clks TEGRA194_CLK_EXTPERIPH1>,
            //           <&bpmp_clks TEGRA194_CLK_EXTPERIPH1>;
                clock-names = "extperiph1", "pllp_grtba";
                mclk = "extperiph1";
                nvidia,gmsl-ser-device = <&isp_b>;
                nvidia,gmsl-dser-device = <&dser_0>;
                nvidia,fpga-device  = <&t4_fpga>;

                compatible = "nvidia,tier4_imx490";

                reg = <0x2c>;

                /* Physical dimensions of sensor */
                physical_w = "15.0";
                physical_h = "12.5";
                reg_mux = <0>;
                sensor_model ="imx490";

                fsync-mode = "false";

                distortion-correction = "false";

                auto-exposure = "true";

                /* Defines number of frames to be dropped by driver internally after applying */
                /* sensor crop settings. Some sensors send corrupt frames after applying */
                /* crop co-ordinates */
                post_crop_frame_drop = "0";

                /* Convert Gain to unit of dB (decibel) befor passing to kernel driver */
                use_decibel_gain = "true";

                /* enable CID_SENSOR_MODE_ID for sensor modes selection */
                use_sensor_mode_id = "true";

                /**
                * A modeX node is required to support v4l2 driver
                * implementation with NVIDIA camera software stack
                *
                * mclk_khz = "";
                * Standard MIPI driving clock, typically 24MHz
                *
                * num_lanes = "";
                * Number of lane channels sensor is programmed to output
                *
                * tegra_sinterface = "";
                * The base tegra serial interface lanes are connected to
                *
                * vc_id = "";
                * The virtual channel id of the sensor.
                *
                * discontinuous_clk = "";
                * The sensor is programmed to use a discontinuous clock on MIPI lanes
                *
                * dpcm_enable = "true";
                * The sensor is programmed to use a DPCM modes
                *
                * cil_settletime = "";
                * MIPI lane settle time value.
                * A "0" value attempts to autocalibrate based on mclk_khz and pix_clk_hz
                *
                * active_w = "";
                * Pixel active region width
                *
                * active_h = "";
                * Pixel active region height
                *
                * dynamic_pixel_bit_depth = "";
                * sensor dynamic bit depth for sensor mode
                *
                * csi_pixel_bit_depth = "";
                * sensor output bit depth for sensor mode
                *
                * mode_type="";
                * Sensor mode type, For eg: yuv, Rgb, bayer, bayer_wdr_pwl
                *
                * pixel_phase="";
                * Pixel phase for sensor mode, For eg: rggb, vyuy, rgb888
                *
                * readout_orientation = "0";
                * Based on camera module orientation.
                * Only change readout_orientation if you specifically
                * Program a different readout order for this mode
                *
                * line_length = "";
                * Pixel line length (width) for sensor mode.
                * This is used to calibrate features in our camera stack.
                *
                * pix_clk_hz = "";
                * Sensor pixel clock used for calculations like exposure and framerate
                *
                *
                *
                *
                * inherent_gain = "";
                * Gain obtained inherently from mode (ie. pixel binning)
                *
                * min_gain_val = ""; (floor to 6 decimal places)
                * max_gain_val = ""; (floor to 6 decimal places)
                * Gain limits for mode
                * if use_decibel_gain = "true", please set the gain as decibel
                *
                * min_exp_time = ""; (ceil to integer)
                * max_exp_time = ""; (ceil to integer)
                * Exposure Time limits for mode (us)
                *
                *
                * min_hdr_ratio = "";
                * max_hdr_ratio = "";
                * HDR Ratio limits for mode
                *
                * min_framerate = "";
                * max_framerate = "";
                * Framerate limits for mode (fps)
                *
                * embedded_metadata_height = "";
                * Sensor embedded metadata height in units of rows.
                * If sensor does not support embedded metadata value should be 0.
                */
                mode0 {/*mode IMX490_MODE_2880X1860_CROP_30FPS*/
                    mclk_khz = "24000";
                    num_lanes = "2";
                    tegra_sinterface = "serial_a";
                    vc_id = "1";

                    discontinuous_clk = "no";
                    dpcm_enable = "false";
                    cil_settletime = "0";
                    dynamic_pixel_bit_depth = "16";
                    csi_pixel_bit_depth = "16";
                    mode_type = "yuv";
                    pixel_phase = "uyvy";

                    active_w = "2880";
                    active_h = "1860";
                    readout_orientation = "0";
                    line_length = "2250";
                    inherent_gain = "1";

                    pix_clk_hz = "160704000";
                    // MIPI CSI clock needs to be 1.5GHz to support deskew
                    // MIPI CSI output data rate = 1.5Gbps = (sensor or deserializer pixel clock in hertz) * (bits per pixel) / (number of CSI lanes)
                    // 1500000000 = serdes_pix_clk_hz * csi_pixel_bit_depth / num_lanes
                    // => serdes_pix_clk_hz = 1500000000 * num_lanes / csi_pixel_bit_depth
                    serdes_pix_clk_hz = "187500000";

                    gain_factor = "5";
                    min_gain_val = "0";                         /* dB */
                    max_gain_val = "300";                       /* dB */
                    step_gain_val = "1";                        /* 0.3 */
                    default_gain = "0";
                    min_hdr_ratio = "1";
                    max_hdr_ratio = "1";
                    framerate_factor = "1000000";
                    min_framerate = "0";
                    max_framerate = "40954095";
                    step_framerate = "1";
                    default_framerate = "0";
                    exposure_factor = "1000000";
                    min_exp_time = "0";                         /* us 1 line */
                    max_exp_time = "40954095";
                    step_exp_time = "1";
                    default_exp_time = "0";                 /* us */
                    embedded_metadata_height = "0";
                };

                ports {
                    #address-cells = <1>;
                    #size-cells = <0>;
                    port@0 {
                        reg = <0>;
                        imx490_out1: endpoint {
                            vc-id = <1>;
                            port-index = <0>;
                            bus-width = <2>;
                            remote-endpoint = <&csi_in1>;
                        };
                    };
                };

                gmsl-link {
                    src-csi-port = "b";
                    dst-csi-port = "a";
                    serdes-csi-link = "b";
                    csi-mode = "1x4";
                    st-vc = <0>;
                    vc-id = <1>;
                    num-lanes = <2>;
                    streams = "ued-u1","yuv8";
                };
            };

            imx490_a@2b {
                status = "okay";
                def-addr = <0x1a>;
                /* Define any required hw resources needed by driver */
                /* ie. clocks, io pins, power sources */
            //  clocks = <&bpmp_clks TEGRA194_CLK_EXTPERIPH1>,
            //          <&bpmp_clks TEGRA194_CLK_EXTPERIPH1>;
                clock-names = "extperiph1", "pllp_grtba";
                mclk = "extperiph1";
                nvidia,gmsl-ser-device  = <&isp_a>;
                nvidia,gmsl-dser-device = <&dser_0>;
                nvidia,fpga-device  = <&t4_fpga>;

                compatible = "nvidia,tier4_imx490";

                reg = <0x2b>;

                /* Physical dimensions of sensor */
                physical_w = "15.0";
                physical_h = "12.5";
                reg_mux = <0>;
                sensor_model ="imx490";

                fsync-mode = "false";

                distortion-correction = "false";

                auto-exposure = "true";

                /* Defines number of frames to be dropped by driver internally after applying */
                /* sensor crop settings. Some sensors send corrupt frames after applying */
                /* crop co-ordinates */
                post_crop_frame_drop = "0";

                /* Convert Gain to unit of dB (decibel) befor passing to kernel driver */
                use_decibel_gain = "true";

                /* enable CID_SENSOR_MODE_ID for sensor modes selection */
                use_sensor_mode_id = "true";

                mode0 {/*mode IMX490_MODE_2880X1860_CROP_30FPS*/
                    mclk_khz = "24000";
                    num_lanes = "2";
                    tegra_sinterface = "serial_a";
                    vc_id = "0";

                    discontinuous_clk = "no";
                    dpcm_enable = "false";
                    cil_settletime = "0";
                    dynamic_pixel_bit_depth = "16";
                    csi_pixel_bit_depth = "16";
                    mode_type = "yuv";
                    pixel_phase = "uyvy";

                    active_w = "2880";
                    active_h = "1860";
                    readout_orientation = "0";
                    line_length = "2250";
                    inherent_gain = "1";

                    pix_clk_hz = "160704000";
                    // MIPI CSI clock needs to be 1.5GHz to support deskew
                    // MIPI CSI output data rate = 1.5Gbps = (sensor or deserializer pixel clock in hertz) * (bits per pixel) / (number of CSI lanes)
                    // 1500000000 = serdes_pix_clk_hz * csi_pixel_bit_depth / num_lanes
                    // => serdes_pix_clk_hz = 1500000000 * num_lanes / csi_pixel_bit_depth
                    serdes_pix_clk_hz = "187500000";

                    gain_factor = "5";
                    min_gain_val = "0";                         /* dB */
                    max_gain_val = "300";                       /* dB */
                    step_gain_val = "1";                        /* 0.3 */
                    default_gain = "0";
                    min_hdr_ratio = "1";
                    max_hdr_ratio = "1";
                    framerate_factor = "1000000";
                    min_framerate = "0";
                    max_framerate = "40954095";
                    step_framerate = "1";
                    default_framerate = "0";
                    exposure_factor = "1000000";
                    min_exp_time = "0";                         /* us 1 line */
                    max_exp_time = "40954095";
                    step_exp_time = "1";
                    default_exp_time = "0";                 /* us */
                    embedded_metadata_height = "0";
                };
                ports {
                    #address-cells = <1>;
                    #size-cells = <0>;
                    port@0 {
                        reg = <0>;
                        imx490_out0: endpoint {
                            vc-id = <0>;
                            port-index = <0>;
                            bus-width = <2>;
                            remote-endpoint = <&csi_in0>;
                        };
                    };
                };
                gmsl-link {
                    src-csi-port = "b";     /* Port at which sensor is connected to its serializer device. */
                    dst-csi-port = "a";     /* Destination CSI port on the Jetson side, connected at deserializer. */
                    serdes-csi-link = "a";  /* GMSL link sensor/serializer connected */
                    csi-mode = "1x4";       /*  to sensor CSI mode. */
                    st-vc = <0>;            /* Sensor source default VC ID: 0 unless overridden by sensor. */
                    vc-id = <0>;            /* Destination VC ID, assigned to sensor stream by deserializer. */
                    num-lanes = <2>;        /* Number of CSI lanes used. */
                    streams = "ued-u1","yuv8"; /* Types of streams sensor is streaming. */
                };
            };
        };
    };

    fragment@1 {
      target = <&mux_i2c_1>;
      __overlay__ {
        i2c-mux,deselect-on-exit;
        #address-cells = <1>;
        #size-cells = <0>;

        ser_prima: max9295_prim@62 {
            compatible = "nvidia,tier4_max9295";
            reg = <0x62>;
            is-prim-ser;
        };
        ser_c: max9295_a@42 {
            compatible = "nvidia,tier4_max9295";
            reg = <0x42>;
            nvidia,gmsl-dser-device = <&dser_1>;
            prim-parent = <&ser_prima>;
        };
        ser_d: max9295_b@60 {
            compatible = "nvidia,tier4_max9295";
            reg = <0x60>;
            nvidia,gmsl-dser-device = <&dser_1>;
            prim-parent = <&ser_prima>;
        };
        isp_prima: gw5300_prim@6d {
            compatible = "nvidia,tier4_gw5300";
            reg = <0x6d>;
            is-prim-isp;
        };
        isp_c: gw5300_a@6e {
            compatible = "nvidia,tier4_gw5300";
            reg = <0x6e>;
        };
        isp_d: gw5300_b@6f {
            compatible = "nvidia,tier4_gw5300";
            reg = <0x6f>;
        };

        imx490_d@2c {
            status = "okay";
            def-addr = <0x1a>;
            /* Define any required hw resources needed by driver */
            /* ie. clocks, io pins, power sources */
        //  clocks = <&bpmp_clks TEGRA194_CLK_EXTPERIPH1>,
        //          <&bpmp_clks TEGRA194_CLK_EXTPERIPH1>;
            clock-names = "extperiph1", "pllp_grtba";
            mclk = "extperiph1";

            nvidia,gmsl-ser-device = <&isp_d>;
            nvidia,gmsl-dser-device = <&dser_1>;
            nvidia,fpga-device  = <&t4_fpga>;

            compatible = "nvidia,tier4_imx490";

            reg = <0x2c>;

            /* Physical dimensions of sensor */
            physical_w = "15.0";
            physical_h = "12.5";
            reg_mux = <1>;
            sensor_model ="imx490";

            fsync-mode = "false";

            distortion-correction = "false";

            auto-exposure = "true";

            /* Defines number of frames to be dropped by driver internally after applying */
            /* sensor crop settings. Some sensors send corrupt frames after applying */
            /* crop co-ordinates */
            post_crop_frame_drop = "0";

            /* Convert Gain to unit of dB (decibel) befor passing to kernel driver */
            use_decibel_gain = "true";

            /* enable CID_SENSOR_MODE_ID for sensor modes selection */
            use_sensor_mode_id = "true";

            /**
            * A modeX node is required to support v4l2 driver
            * implementation with NVIDIA camera software stack
            *
            * mclk_khz = "";
            * Standard MIPI driving clock, typically 24MHz
            *
            * num_lanes = "";
            * Number of lane channels sensor is programmed to output
            *
            * tegra_sinterface = "";
            * The base tegra serial interface lanes are connected to
            *
            * vc_id = "";
            * The virtual channel id of the sensor.
            *
            * discontinuous_clk = "";
            * The sensor is programmed to use a discontinuous clock on MIPI lanes
            *
            * dpcm_enable = "true";
            * The sensor is programmed to use a DPCM modes
            *
            * cil_settletime = "";
            * MIPI lane settle time value.
            * A "0" value attempts to autocalibrate based on mclk_khz and pix_clk_hz
            *
            * active_w = "";
            * Pixel active region width
            *
            * active_h = "";
            * Pixel active region height
            *
            * dynamic_pixel_bit_depth = "";
            * sensor dynamic bit depth for sensor mode
            *
            * csi_pixel_bit_depth = "";
            * sensor output bit depth for sensor mode
            *
            * mode_type="";
            * Sensor mode type, For eg: yuv, Rgb, bayer, bayer_wdr_pwl
            *
            * pixel_phase="";
            * Pixel phase for sensor mode, For eg: rggb, vyuy, rgb888
            *
            * readout_orientation = "0";
            * Based on camera module orientation.
            * Only change readout_orientation if you specifically
            * Program a different readout order for this mode
            *
            * line_length = "";
            * Pixel line length (width) for sensor mode.
            * This is used to calibrate features in our camera stack.
            *
            * pix_clk_hz = "";
            * Sensor pixel clock used for calculations like exposure and framerate
            *
            *
            *
            *
            * inherent_gain = "";
            * Gain obtained inherently from mode (ie. pixel binning)
            *
            * min_gain_val = ""; (floor to 6 decimal places)
            * max_gain_val = ""; (floor to 6 decimal places)
            * Gain limits for mode
            * if use_decibel_gain = "true", please set the gain as decibel
            *
            * min_exp_time = ""; (ceil to integer)
            * max_exp_time = ""; (ceil to integer)
            * Exposure Time limits for mode (us)
            *
            *
            * min_hdr_ratio = "";
            * max_hdr_ratio = "";
            * HDR Ratio limits for mode
            *
            * min_framerate = "";
            * max_framerate = "";
            * Framerate limits for mode (fps)
            *
            * embedded_metadata_height = "";
            * Sensor embedded metadata height in units of rows.
            * If sensor does not support embedded metadata value should be 0.
            */
            mode0 {/*mode IMX490_MODE_2880X1860_CROP_30FPS*/
                mclk_khz = "24000";
                num_lanes = "2";
                tegra_sinterface = "serial_c";
                vc_id = "1";

                discontinuous_clk = "no";
                dpcm_enable = "false";
                cil_settletime = "0";
                dynamic_pixel_bit_depth = "16";
                csi_pixel_bit_depth = "16";
                mode_type = "yuv";
                pixel_phase = "uyvy";
                active_w = "2880";
                active_h = "1860";
                readout_orientation = "0";
                line_length = "2250";
                inherent_gain = "1";

                pix_clk_hz = "160704000";
                // MIPI CSI clock needs to be 1.5GHz to support deskew
                // MIPI CSI output data rate = 1.5Gbps = (sensor or deserializer pixel clock in hertz) * (bits per pixel) / (number of CSI lanes)
                // 1500000000 = serdes_pix_clk_hz * csi_pixel_bit_depth / num_lanes
                // => serdes_pix_clk_hz = 1500000000 * num_lanes / csi_pixel_bit_depth
                serdes_pix_clk_hz = "187500000";

                gain_factor = "5";
                min_gain_val = "0";                         /* dB */
                max_gain_val = "300";                       /* dB */
                step_gain_val = "1";                        /* 0.3 */
                default_gain = "0";
                min_hdr_ratio = "1";
                max_hdr_ratio = "1";
                framerate_factor = "1000000";
                min_framerate = "0";
                max_framerate = "40954095";
                step_framerate = "1";
                default_framerate = "0";
                exposure_factor = "1000000";
                min_exp_time = "0";                         /* us 1 line */
                max_exp_time = "40954095";
                step_exp_time = "1";
                default_exp_time = "0";                 /* us */
                embedded_metadata_height = "0";
            };

            ports {
                #address-cells = <1>;
                #size-cells = <0>;
                port@0 {
                    reg = <0>;
                    imx490_out3: endpoint {
                        vc-id = <1>;
                        port-index = <2>;
                        bus-width = <2>;
                        remote-endpoint = <&csi_in3>;
                    };
                };
            };
            gmsl-link {
                src-csi-port = "b";
                dst-csi-port = "a";
                serdes-csi-link = "b";
                csi-mode = "1x4";
                st-vc = <0>;
                vc-id = <1>;
                num-lanes = <2>;
                streams = "ued-u1","yuv8";
            };
        };

        imx490_c@2b {
            status = "okay";
            def-addr = <0x1a>;

            /* Define any required hw resources needed by driver */
            /* ie. clocks, io pins, power sources */
        //  clocks = <&bpmp_clks TEGRA194_CLK_EXTPERIPH1>,
        //          <&bpmp_clks TEGRA194_CLK_EXTPERIPH1>;
            clock-names = "extperiph1", "pllp_grtba";
            mclk = "extperiph1";

            nvidia,gmsl-ser-device = <&isp_c>;
            nvidia,gmsl-dser-device = <&dser_1>;
            nvidia,fpga-device  = <&t4_fpga>;

            compatible = "nvidia,tier4_imx490";

            reg = <0x2b>;

            /* Physical dimensions of sensor */
            physical_w = "15.0";
            physical_h = "12.5";
            reg_mux = <1>;
            sensor_model ="imx490";

            fsync-mode = "false";

            distortion-correction = "false";

            auto-exposure = "true";

            /* Defines number of frames to be dropped by driver internally after applying */
            /* sensor crop settings. Some sensors send corrupt frames after applying */
            /* crop co-ordinates */
            post_crop_frame_drop = "0";

            /* Convert Gain to unit of dB (decibel) befor passing to kernel driver */
            use_decibel_gain = "true";

            /* enable CID_SENSOR_MODE_ID for sensor modes selection */
            use_sensor_mode_id = "true";

            /**
            * A modeX node is required to support v4l2 driver
            * implementation with NVIDIA camera software stack
            *
            * mclk_khz = "";
            * Standard MIPI driving clock, typically 24MHz
            *
            * num_lanes = "";
            * Number of lane channels sensor is programmed to output
            *
            * tegra_sinterface = "";
            * The base tegra serial interface lanes are connected to
            *
            * vc_id = "";
            * The virtual channel id of the sensor.
            *
            * discontinuous_clk = "";
            * The sensor is programmed to use a discontinuous clock on MIPI lanes
            *
            * dpcm_enable = "true";
            * The sensor is programmed to use a DPCM modes
            *
            * cil_settletime = "";
            * MIPI lane settle time value.
            * A "0" value attempts to autocalibrate based on mclk_khz and pix_clk_hz
            *
            * active_w = "";
            * Pixel active region width
            *
            * active_h = "";
            * Pixel active region height
            *
            * dynamic_pixel_bit_depth = "";
            * sensor dynamic bit depth for sensor mode
            *
            * csi_pixel_bit_depth = "";
            * sensor output bit depth for sensor mode
            *
            * mode_type="";
            * Sensor mode type, For eg: yuv, Rgb, bayer, bayer_wdr_pwl
            *
            * pixel_phase="";
            * Pixel phase for sensor mode, For eg: rggb, vyuy, rgb888
            *
            * readout_orientation = "0";
            * Based on camera module orientation.
            * Only change readout_orientation if you specifically
            * Program a different readout order for this mode
            *
            * line_length = "";
            * Pixel line length (width) for sensor mode.
            * This is used to calibrate features in our camera stack.
            *
            * pix_clk_hz = "";
            * Sensor pixel clock used for calculations like exposure and framerate
            *
            *
            *
            *
            * inherent_gain = "";
            * Gain obtained inherently from mode (ie. pixel binning)
            *
            * min_gain_val = ""; (floor to 6 decimal places)
            * max_gain_val = ""; (floor to 6 decimal places)
            * Gain limits for mode
            * if use_decibel_gain = "true", please set the gain as decibel
            *
            * min_exp_time = ""; (ceil to integer)
            * max_exp_time = ""; (ceil to integer)
            * Exposure Time limits for mode (us)
            *
            *
            * min_hdr_ratio = "";
            * max_hdr_ratio = "";
            * HDR Ratio limits for mode
            *
            * min_framerate = "";
            * max_framerate = "";
            * Framerate limits for mode (fps)
            *
            * embedded_metadata_height = "";
            * Sensor embedded metadata height in units of rows.
            * If sensor does not support embedded metadata value should be 0.
            */
            mode0 {/*mode IMX490_MODE_2880X1860_CROP_30FPS*/
                mclk_khz = "24000";
                num_lanes = "2";
                tegra_sinterface = "serial_c";
                vc_id = "0";

                discontinuous_clk = "no";
                dpcm_enable = "false";
                cil_settletime = "0";
                dynamic_pixel_bit_depth = "16";
                csi_pixel_bit_depth = "16";
                mode_type = "yuv";
                pixel_phase = "uyvy";
                active_w = "2880";
                active_h = "1860";
                readout_orientation = "0";
                line_length = "2250";
                inherent_gain = "1";

                pix_clk_hz = "160704000";
                // MIPI CSI clock needs to be 1.5GHz to support deskew
                // MIPI CSI output data rate = 1.5Gbps = (sensor or deserializer pixel clock in hertz) * (bits per pixel) / (number of CSI lanes)
                // 1500000000 = serdes_pix_clk_hz * csi_pixel_bit_depth / num_lanes
                // => serdes_pix_clk_hz = 1500000000 * num_lanes / csi_pixel_bit_depth
                serdes_pix_clk_hz = "187500000";

                gain_factor = "5";
                min_gain_val = "0";                         /* dB */
                max_gain_val = "300";                       /* dB */
                step_gain_val = "1";                        /* 0.3 */
                default_gain = "0";
                min_hdr_ratio = "1";
                max_hdr_ratio = "1";
                framerate_factor = "1000000";
                min_framerate = "0";
                max_framerate = "40954095";
                step_framerate = "1";
                default_framerate = "0";
                exposure_factor = "1000000";
                min_exp_time = "0";                         /* us 1 line */
                max_exp_time = "40954095";
                step_exp_time = "1";
                default_exp_time = "0";                 /* us */
                embedded_metadata_height = "0";
            };

            ports {
                #address-cells = <1>;
                #size-cells = <0>;
                port@0 {
                    reg = <0>;
                    imx490_out2: endpoint {
                        vc-id = <0>;
                        port-index = <2>;
                        bus-width = <2>;
                        remote-endpoint = <&csi_in2>;
                    };
                };
            };
            gmsl-link {
                src-csi-port = "b";             /* Port at which sensor  is connected to its serializer device. */
                dst-csi-port = "a";             /* Destination CSI port on the Jetson side, connected at deserializer. */
                serdes-csi-link = "a";          /* GMSL link sensor/serializer connected */
                csi-mode = "1x4";               /*  to sensor CSI mode. */
                st-vc = <0>;                    /* Sensor source default VC ID: 0 unless overridden by sensor. */
                vc-id = <0>;                    /* Destination VC ID, assigned to sensor stream by deserializer. */
                num-lanes = <2>;                /* Number of CSI lanes used. */
                streams = "ued-u1","yuv8";      /* Types of streams sensor is streaming. */
            };
        };
      };
    };

    fragment@2 {
      target = <&mux_i2c_2>;
      __overlay__ {
        i2c-mux,deselect-on-exit;
        #address-cells = <1>;
        #size-cells = <0>;

        ser_primb: max9295_prim@62 {
            compatible = "nvidia,tier4_max9295";
            reg = <0x62>;
            is-prim-ser;
        };
        ser_e: max9295_a@42 {
            compatible = "nvidia,tier4_max9295";
            reg = <0x42>;
            nvidia,gmsl-dser-device = <&dser_2>;
            prim-parent = <&ser_primb>;
        };
        ser_f: max9295_b@60 {
            compatible = "nvidia,tier4_max9295";
            reg = <0x60>;
            nvidia,gmsl-dser-device = <&dser_2>;
            prim-parent = <&ser_primb>;
        };
        isp_primb: gw5300_prim@6d {
            compatible = "nvidia,tier4_gw5300";
            reg = <0x6d>;
            is-prim-isp;
        };
        isp_e: gw5300_a@6e {
            compatible = "nvidia,tier4_gw5300";
            reg = <0x6e>;
        };
        isp_f: gw5300_b@6f {
            compatible = "nvidia,tier4_gw5300";
            reg = <0x6f>;
        };

        imx490_f@2c {
            status = "okay";
            def-addr = <0x1a>;

            /* Define any required hw resources needed by driver */
            /* ie. clocks, io pins, power sources */
        //  clocks = <&bpmp_clks TEGRA194_CLK_EXTPERIPH1>,
        //          <&bpmp_clks TEGRA194_CLK_EXTPERIPH1>;
            clock-names = "extperiph1", "pllp_grtba";
            mclk = "extperiph1";

            nvidia,gmsl-ser-device = <&isp_f>;
            nvidia,gmsl-dser-device = <&dser_2>;
            nvidia,fpga-device  = <&t4_fpga>;

            compatible = "nvidia,tier4_imx490";

            reg = <0x2c>;

            /* Physical dimensions of sensor */
            physical_w = "15.0";
            physical_h = "12.5";
            reg_mux = <2>;
            sensor_model ="imx490";

            fsync-mode = "false";

            distortion-correction = "false";

            auto-exposure = "true";

            /* Defines number of frames to be dropped by driver internally after applying */
            /* sensor crop settings. Some sensors send corrupt frames after applying */
            /* crop co-ordinates */
            post_crop_frame_drop = "0";

            /* Convert Gain to unit of dB (decibel) befor passing to kernel driver */
            use_decibel_gain = "true";

            /* enable CID_SENSOR_MODE_ID for sensor modes selection */
            use_sensor_mode_id = "true";

            /**
            * A modeX node is required to support v4l2 driver
            * implementation with NVIDIA camera software stack
            *
            * mclk_khz = "";
            * Standard MIPI driving clock, typically 24MHz
            *
            * num_lanes = "";
            * Number of lane channels sensor is programmed to output
            *
            * tegra_sinterface = "";
            * The base tegra serial interface lanes are connected to
            *
            * vc_id = "";
            * The virtual channel id of the sensor.
            *
            * discontinuous_clk = "";
            * The sensor is programmed to use a discontinuous clock on MIPI lanes
            *
            * dpcm_enable = "true";
            * The sensor is programmed to use a DPCM modes
            *
            * cil_settletime = "";
            * MIPI lane settle time value.
            * A "0" value attempts to autocalibrate based on mclk_khz and pix_clk_hz
            *
            * active_w = "";
            * Pixel active region width
            *
            * active_h = "";
            * Pixel active region height
            *
            * dynamic_pixel_bit_depth = "";
            * sensor dynamic bit depth for sensor mode
            *
            * csi_pixel_bit_depth = "";
            * sensor output bit depth for sensor mode
            *
            * mode_type="";
            * Sensor mode type, For eg: yuv, Rgb, bayer, bayer_wdr_pwl
            *
            * pixel_phase="";
            * Pixel phase for sensor mode, For eg: rggb, vyuy, rgb888
            *
            * readout_orientation = "0";
            * Based on camera module orientation.
            * Only change readout_orientation if you specifically
            * Program a different readout order for this mode
            *
            * line_length = "";
            * Pixel line length (width) for sensor mode.
            * This is used to calibrate features in our camera stack.
            *
            * pix_clk_hz = "";
            * Sensor pixel clock used for calculations like exposure and framerate
            *
            *
            *
            *
            * inherent_gain = "";
            * Gain obtained inherently from mode (ie. pixel binning)
            *
            * min_gain_val = ""; (floor to 6 decimal places)
            * max_gain_val = ""; (floor to 6 decimal places)
            * Gain limits for mode
            * if use_decibel_gain = "true", please set the gain as decibel
            *
            * min_exp_time = ""; (ceil to integer)
            * max_exp_time = ""; (ceil to integer)
            * Exposure Time limits for mode (us)
            *
            *
            * min_hdr_ratio = "";
            * max_hdr_ratio = "";
            * HDR Ratio limits for mode
            *
            * min_framerate = "";
            * max_framerate = "";
            * Framerate limits for mode (fps)
            *
            * embedded_metadata_height = "";
            * Sensor embedded metadata height in units of rows.
            * If sensor does not support embedded metadata value should be 0.
            */

             mode0 {/*mode IMX490_MODE_2880X1860_CROP_30FPS*/
                     mclk_khz = "24000";
                     num_lanes = "2";
                     tegra_sinterface = "serial_e";
                     vc_id = "1";

                     discontinuous_clk = "no";
                     dpcm_enable = "false";
                     cil_settletime = "0";
                     dynamic_pixel_bit_depth = "16";
                     csi_pixel_bit_depth = "16";
                     mode_type = "yuv";
                     pixel_phase = "uyvy";
                     active_w = "2880";
                     active_h = "1860";
                     readout_orientation = "0";
                     line_length = "2250";
                     inherent_gain = "1";

                     pix_clk_hz = "160704000";
                     // MIPI CSI clock needs to be 1.5GHz to support deskew
                    // MIPI CSI output data rate = 1.5Gbps = (sensor or deserializer pixel clock in hertz) * (bits per pixel) / (number of CSI lanes)
                    // 1500000000 = serdes_pix_clk_hz * csi_pixel_bit_depth / num_lanes
                    // => serdes_pix_clk_hz = 1500000000 * num_lanes / csi_pixel_bit_depth
                    serdes_pix_clk_hz = "187500000";

                     gain_factor = "5";
                     min_gain_val = "0";                         /* dB */
                     max_gain_val = "300";                       /* dB */
                     step_gain_val = "1";                        /* 0.3 */
                     default_gain = "0";
                     min_hdr_ratio = "1";
                     max_hdr_ratio = "1";
                     framerate_factor = "1000000";
                     min_framerate = "0";
                     max_framerate = "40954095";
                     step_framerate = "1";
                     default_framerate = "0";
                     exposure_factor = "1000000";
                     min_exp_time = "0";                         /* us 1 line */
                     max_exp_time = "40954095";
                     step_exp_time = "1";
                     default_exp_time = "0";                 /* us */
                     embedded_metadata_height = "0";
                 };
            ports {
                #address-cells = <1>;
                #size-cells = <0>;
                port@0 {
                    reg = <0>;
                    imx490_out5: endpoint {
                        vc-id = <1>;
                        port-index = <4>;
                        bus-width = <2>;
                        remote-endpoint = <&csi_in5>;
                    };
                };
            };
            gmsl-link {
                src-csi-port = "b";
                dst-csi-port = "a";
                serdes-csi-link = "b";
                csi-mode = "1x4";
                st-vc = <0>;
                vc-id = <1>;
                num-lanes = <2>;
                streams = "ued-u1","yuv8";
            };
        };

        imx490_e@2b {
            status = "okay";
            def-addr = <0x1a>;

            /* Define any required hw resources needed by driver */
            /* ie. clocks, io pins, power sources */
        //  clocks = <&bpmp_clks TEGRA194_CLK_EXTPERIPH1>,
        //          <&bpmp_clks TEGRA194_CLK_EXTPERIPH1>;
            clock-names = "extperiph1", "pllp_grtba";
            mclk = "extperiph1";

            nvidia,gmsl-ser-device = <&isp_e>;
            nvidia,gmsl-dser-device = <&dser_2>;
            nvidia,fpga-device  = <&t4_fpga>;

            compatible = "nvidia,tier4_imx490";

            reg = <0x2b>;

            /* Physical dimensions of sensor */
            physical_w = "15.0";
            physical_h = "12.5";
            reg_mux = <2>;
            sensor_model ="imx490";

            fsync-mode = "false";

            distortion-correction = "false";

            auto-exposure = "true";

            /* Defines number of frames to be dropped by driver internally after applying */
            /* sensor crop settings. Some sensors send corrupt frames after applying */
            /* crop co-ordinates */
            post_crop_frame_drop = "0";

            /* Convert Gain to unit of dB (decibel) befor passing to kernel driver */
            use_decibel_gain = "true";

            /* enable CID_SENSOR_MODE_ID for sensor modes selection */
            use_sensor_mode_id = "true";

            /**
            * A modeX node is required to support v4l2 driver
            * implementation with NVIDIA camera software stack
            *
            * mclk_khz = "";
            * Standard MIPI driving clock, typically 24MHz
            *
            * num_lanes = "";
            * Number of lane channels sensor is programmed to output
            *
            * tegra_sinterface = "";
            * The base tegra serial interface lanes are connected to
            *
            * vc_id = "";
            * The virtual channel id of the sensor.
            *
            * discontinuous_clk = "";
            * The sensor is programmed to use a discontinuous clock on MIPI lanes
            *
            * dpcm_enable = "true";
            * The sensor is programmed to use a DPCM modes
            *
            * cil_settletime = "";
            * MIPI lane settle time value.
            * A "0" value attempts to autocalibrate based on mclk_khz and pix_clk_hz
            *
            * active_w = "";
            * Pixel active region width
            *
            * active_h = "";
            * Pixel active region height
            *
            * dynamic_pixel_bit_depth = "";
            * sensor dynamic bit depth for sensor mode
            *
            * csi_pixel_bit_depth = "";
            * sensor output bit depth for sensor mode
            *
            * mode_type="";
            * Sensor mode type, For eg: yuv, Rgb, bayer, bayer_wdr_pwl
            *
            * pixel_phase="";
            * Pixel phase for sensor mode, For eg: rggb, vyuy, rgb888
            *
            * readout_orientation = "0";
            * Based on camera module orientation.
            * Only change readout_orientation if you specifically
            * Program a different readout order for this mode
            *
            * line_length = "";
            * Pixel line length (width) for sensor mode.
            * This is used to calibrate features in our camera stack.
            *
            * pix_clk_hz = "";
            * Sensor pixel clock used for calculations like exposure and framerate
            *
            *
            *
            *
            * inherent_gain = "";
            * Gain obtained inherently from mode (ie. pixel binning)
            *
            * min_gain_val = ""; (floor to 6 decimal places)
            * max_gain_val = ""; (floor to 6 decimal places)
            * Gain limits for mode
            * if use_decibel_gain = "true", please set the gain as decibel
            *
            * min_exp_time = ""; (ceil to integer)
            * max_exp_time = ""; (ceil to integer)
            * Exposure Time limits for mode (us)
            *
            *
            * min_hdr_ratio = "";
            * max_hdr_ratio = "";
            * HDR Ratio limits for mode
            *
            * min_framerate = "";
            * max_framerate = "";
            * Framerate limits for mode (fps)
            *
            * embedded_metadata_height = "";
            * Sensor embedded metadata height in units of rows.
            * If sensor does not support embedded metadata value should be 0.
            */

            mode0 {/*mode IMX490_MODE_2880X1860_CROP_30FPS*/
                     mclk_khz = "24000";
                     num_lanes = "2";
                     tegra_sinterface = "serial_e";
                     vc_id = "0";
                     
                     discontinuous_clk = "no";
                     dpcm_enable = "false";
                     cil_settletime = "0";
                     dynamic_pixel_bit_depth = "16";
                     csi_pixel_bit_depth = "16";
                     mode_type = "yuv";
                     pixel_phase = "uyvy";
                     active_w = "2880";
                     active_h = "1860";
                     readout_orientation = "0";
                     line_length = "2250";
                     inherent_gain = "1";

                     pix_clk_hz = "160704000";
                     // MIPI CSI clock needs to be 1.5GHz to support deskew
                     // MIPI CSI output data rate = 1.5Gbps = (sensor or deserializer pixel clock in hertz) * (bits per pixel) / (number of CSI lanes)
                     // 1500000000 = serdes_pix_clk_hz * csi_pixel_bit_depth / num_lanes
                     // => serdes_pix_clk_hz = 1500000000 * num_lanes / csi_pixel_bit_depth
                     serdes_pix_clk_hz = "187500000";

                     gain_factor = "5";
                     min_gain_val = "0";                         /* dB */
                     max_gain_val = "300";                       /* dB */
                     step_gain_val = "1";                        /* 0.3 */
                     default_gain = "0";
                     min_hdr_ratio = "1";
                     max_hdr_ratio = "1";
                     framerate_factor = "1000000";
                     min_framerate = "0";
                     max_framerate = "40954095";
                     step_framerate = "1";
                     default_framerate = "0";
                     exposure_factor = "1000000";
                     min_exp_time = "0";                         /* us 1 line */
                     max_exp_time = "40954095";
                     step_exp_time = "1";
                     default_exp_time = "0";                 /* us */
                     embedded_metadata_height = "0";
                 };

            ports {
                #address-cells = <1>;
                #size-cells = <0>;
                port@0 {
                    reg = <0>;
                    imx490_out4: endpoint {
                        vc-id = <0>;
                        port-index = <4>;
                        bus-width = <2>;
                        remote-endpoint = <&csi_in4>;
                    };
                };
            };
            gmsl-link {
                src-csi-port = "b";
                dst-csi-port = "a";
                serdes-csi-link = "a";
                csi-mode = "1x4";
                st-vc = <0>;
                vc-id = <0>;
                num-lanes = <2>;
                streams = "ued-u1","yuv8";
            };
        };
      };
    };

    fragment@3 {
      target = <&mux_i2c_3>;
      __overlay__ {
        i2c-mux,deselect-on-exit;
        #address-cells = <1>;
        #size-cells = <0>;

        ser_primc: max9295_prim@62 {
            compatible = "nvidia,tier4_max9295";
            reg = <0x62>;
            is-prim-ser;
        };
        ser_g: max9295_a@42 {
            compatible = "nvidia,tier4_max9295";
            reg = <0x42>;
            nvidia,gmsl-dser-device = <&dser_3>;
            prim-parent = <&ser_primc>;
        };
        ser_h: max9295_b@60 {
            compatible = "nvidia,tier4_max9295";
            reg = <0x60>;
            nvidia,gmsl-dser-device = <&dser_3>;
            prim-parent = <&ser_primc>;
        };
        isp_primc: gw5300_prim@6d {
            compatible = "nvidia,tier4_gw5300";
            reg = <0x6d>;
            is-prim-isp;
        };
        isp_g: gw5300_a@6e {
            compatible = "nvidia,tier4_gw5300";
            reg = <0x6e>;
        };
        isp_h: gw5300_b@6f {
            compatible = "nvidia,tier4_gw5300";
            reg = <0x6f>;
        };

        imx490_h@2c {
            status = "okay";
            def-addr = <0x1a>;

            /* Define any required hw resources needed by driver */
            /* ie. clocks, io pins, power sources */
        //  clocks = <&bpmp_clks TEGRA194_CLK_EXTPERIPH1>,
        //          <&bpmp_clks TEGRA194_CLK_EXTPERIPH1>;
            clock-names = "extperiph1", "pllp_grtba";
            mclk = "extperiph1";

            nvidia,gmsl-ser-device = <&isp_h>;
            nvidia,gmsl-dser-device = <&dser_3>;
            nvidia,fpga-device  = <&t4_fpga>;

            compatible = "nvidia,tier4_imx490";

            reg = <0x2c>;

            /* Physical dimensions of sensor */
            physical_w = "15.0";
            physical_h = "12.5";
            reg_mux = <3>;
            sensor_model ="imx490";

            fsync-mode = "false";

            distortion-correction = "false";

            auto-exposure = "true";

            /* Defines number of frames to be dropped by driver internally after applying */
            /* sensor crop settings. Some sensors send corrupt frames after applying */
            /* crop co-ordinates */
            post_crop_frame_drop = "0";

            /* Convert Gain to unit of dB (decibel) befor passing to kernel driver */
            use_decibel_gain = "true";

            /* enable CID_SENSOR_MODE_ID for sensor modes selection */
            use_sensor_mode_id = "true";

            /**
            * A modeX node is required to support v4l2 driver
            * implementation with NVIDIA camera software stack
            *
            * mclk_khz = "";
            * Standard MIPI driving clock, typically 24MHz
            *
            * num_lanes = "";
            * Number of lane channels sensor is programmed to output
            *
            * tegra_sinterface = "";
            * The base tegra serial interface lanes are connected to
            *
            * vc_id = "";
            * The virtual channel id of the sensor.
            *
            * discontinuous_clk = "";
            * The sensor is programmed to use a discontinuous clock on MIPI lanes
            *
            * dpcm_enable = "true";
            * The sensor is programmed to use a DPCM modes
            *
            * cil_settletime = "";
            * MIPI lane settle time value.
            * A "0" value attempts to autocalibrate based on mclk_khz and pix_clk_hz
            *
            * active_w = "";
            * Pixel active region width
            *
            * active_h = "";
            * Pixel active region height
            *
            * dynamic_pixel_bit_depth = "";
            * sensor dynamic bit depth for sensor mode
            *
            * csi_pixel_bit_depth = "";
            * sensor output bit depth for sensor mode
            *
            * mode_type="";
            * Sensor mode type, For eg: yuv, Rgb, bayer, bayer_wdr_pwl
            *
            * pixel_phase="";
            * Pixel phase for sensor mode, For eg: rggb, vyuy, rgb888
            *
            * readout_orientation = "0";
            * Based on camera module orientation.
            * Only change readout_orientation if you specifically
            * Program a different readout order for this mode
            *
            * line_length = "";
            * Pixel line length (width) for sensor mode.
            * This is used to calibrate features in our camera stack.
            *
            * pix_clk_hz = "";
            * Sensor pixel clock used for calculations like exposure and framerate
            *
            *
            *
            *
            * inherent_gain = "";
            * Gain obtained inherently from mode (ie. pixel binning)
            *
            * min_gain_val = ""; (floor to 6 decimal places)
            * max_gain_val = ""; (floor to 6 decimal places)
            * Gain limits for mode
            * if use_decibel_gain = "true", please set the gain as decibel
            *
            * min_exp_time = ""; (ceil to integer)
            * max_exp_time = ""; (ceil to integer)
            * Exposure Time limits for mode (us)
            *
            *
            * min_hdr_ratio = "";
            * max_hdr_ratio = "";
            * HDR Ratio limits for mode
            *
            * min_framerate = "";
            * max_framerate = "";
            * Framerate limits for mode (fps)
            *
            * embedded_metadata_height = "";
            * Sensor embedded metadata height in units of rows.
            * If sensor does not support embedded metadata value should be 0.
            */

            mode0 {/*mode IMX490_MODE_2880X1860_CROP_30FPS*/
                mclk_khz = "24000";
                num_lanes = "2";
                tegra_sinterface = "serial_g";
                vc_id = "1";

                discontinuous_clk = "no";
                dpcm_enable = "false";
                cil_settletime = "0";
                dynamic_pixel_bit_depth = "16";
                csi_pixel_bit_depth = "16";
                mode_type = "yuv";
                pixel_phase = "uyvy";
                active_w = "2880";
                active_h = "1860";
                readout_orientation = "0";
                line_length = "2250";
                inherent_gain = "1";

                pix_clk_hz = "160704000";
                // MIPI CSI clock needs to be 1.5GHz to support deskew
                // MIPI CSI output data rate = 1.5Gbps = (sensor or deserializer pixel clock in hertz) * (bits per pixel) / (number of CSI lanes)
                // 1500000000 = serdes_pix_clk_hz * csi_pixel_bit_depth / num_lanes
                // => serdes_pix_clk_hz = 1500000000 * num_lanes / csi_pixel_bit_depth
                serdes_pix_clk_hz = "187500000";

                gain_factor = "5";
                min_gain_val = "0";                         /* dB */
                max_gain_val = "300";                       /* dB */
                step_gain_val = "1";                        /* 0.3 */
                default_gain = "0";
                min_hdr_ratio = "1";
                max_hdr_ratio = "1";
                framerate_factor = "1000000";
                min_framerate = "0";
                max_framerate = "40954095";
                step_framerate = "1";
                default_framerate = "0";
                exposure_factor = "1000000";
                min_exp_time = "0";                         /* us 1 line */
                max_exp_time = "40954095";
                step_exp_time = "1";
                default_exp_time = "0";                 /* us */
                embedded_metadata_height = "0";
            };

            ports {
                #address-cells = <1>;
                #size-cells = <0>;
                port@0 {
                    reg = <0>;
                    imx490_out7: endpoint {
                        vc-id = <1>;
                        port-index = <6>;
                        bus-width = <2>;
                        remote-endpoint = <&csi_in7>;
                    };
                };
            };
            gmsl-link {
                src-csi-port = "b";
                dst-csi-port = "a";
                serdes-csi-link = "b";
                csi-mode = "1x4";
                st-vc = <0>;
                vc-id = <1>;
                num-lanes = <2>;
                streams = "ued-u1","yuv8";
            };
        };

        imx490_g@2b {
            status = "okay";
            def-addr = <0x1a>;

            /* Define any required hw resources needed by driver */
            /* ie. clocks, io pins, power sources */
        //  clocks = <&bpmp_clks TEGRA194_CLK_EXTPERIPH1>,
        //          <&bpmp_clks TEGRA194_CLK_EXTPERIPH1>;
            clock-names = "extperiph1", "pllp_grtba";
            mclk = "extperiph1";

            nvidia,gmsl-ser-device = <&isp_g>;
            nvidia,gmsl-dser-device = <&dser_3>;
            nvidia,fpga-device  = <&t4_fpga>;

            compatible = "nvidia,tier4_imx490";

            reg = <0x2b>;

            /* Physical dimensions of sensor */
            physical_w = "15.0";
            physical_h = "12.5";
            reg_mux = <3>;
            sensor_model ="imx490";

            fsync-mode = "false";

            distortion-correction = "false";

            auto-exposure = "true";

            /* Defines number of frames to be dropped by driver internally after applying */
            /* sensor crop settings. Some sensors send corrupt frames after applying */
            /* crop co-ordinates */
            post_crop_frame_drop = "0";

            /* Convert Gain to unit of dB (decibel) befor passing to kernel driver */
            use_decibel_gain = "true";

            /* enable CID_SENSOR_MODE_ID for sensor modes selection */
            use_sensor_mode_id = "true";

            /**
            * A modeX node is required to support v4l2 driver
            * implementation with NVIDIA camera software stack
            *
            * mclk_khz = "";
            * Standard MIPI driving clock, typically 24MHz
            *
            * num_lanes = "";
            * Number of lane channels sensor is programmed to output
            *
            * tegra_sinterface = "";
            * The base tegra serial interface lanes are connected to
            *
            * vc_id = "";
            * The virtual channel id of the sensor.
            *
            * discontinuous_clk = "";
            * The sensor is programmed to use a discontinuous clock on MIPI lanes
            *
            * dpcm_enable = "true";
            * The sensor is programmed to use a DPCM modes
            *
            * cil_settletime = "";
            * MIPI lane settle time value.
            * A "0" value attempts to autocalibrate based on mclk_khz and pix_clk_hz
            *
            * active_w = "";
            * Pixel active region width
            *
            * active_h = "";
            * Pixel active region height
            *
            * dynamic_pixel_bit_depth = "";
            * sensor dynamic bit depth for sensor mode
            *
            * csi_pixel_bit_depth = "";
            * sensor output bit depth for sensor mode
            *
            * mode_type="";
            * Sensor mode type, For eg: yuv, Rgb, bayer, bayer_wdr_pwl
            *
            * pixel_phase="";
            * Pixel phase for sensor mode, For eg: rggb, vyuy, rgb888
            *
            * readout_orientation = "0";
            * Based on camera module orientation.
            * Only change readout_orientation if you specifically
            * Program a different readout order for this mode
            *
            * line_length = "";
            * Pixel line length (width) for sensor mode.
            * This is used to calibrate features in our camera stack.
            *
            * pix_clk_hz = "";
            * Sensor pixel clock used for calculations like exposure and framerate
            *
            *
            *
            *
            * inherent_gain = "";
            * Gain obtained inherently from mode (ie. pixel binning)
            *
            * min_gain_val = ""; (floor to 6 decimal places)
            * max_gain_val = ""; (floor to 6 decimal places)
            * Gain limits for mode
            * if use_decibel_gain = "true", please set the gain as decibel
            *
            * min_exp_time = ""; (ceil to integer)
            * max_exp_time = ""; (ceil to integer)
            * Exposure Time limits for mode (us)
            *
            *
            * min_hdr_ratio = "";
            * max_hdr_ratio = "";
            * HDR Ratio limits for mode
            *
            * min_framerate = "";
            * max_framerate = "";
            * Framerate limits for mode (fps)
            *
            * embedded_metadata_height = "";
            * Sensor embedded metadata height in units of rows.
            * If sensor does not support embedded metadata value should be 0.
            */

            mode0 {/*mode IMX490_MODE_2880X1860_CROP_30FPS*/
                mclk_khz = "24000";
                num_lanes = "2";
                tegra_sinterface = "serial_g";
                vc_id = "0";

                discontinuous_clk = "no";
                dpcm_enable = "false";
                cil_settletime = "0";
                dynamic_pixel_bit_depth = "16";
                csi_pixel_bit_depth = "16";
                mode_type = "yuv";
                pixel_phase = "uyvy";
                active_w = "2880";
                active_h = "1860";
                readout_orientation = "0";
                line_length = "2250";
                inherent_gain = "1";

                pix_clk_hz = "160704000";
                // MIPI CSI clock needs to be 1.5GHz to support deskew
                // MIPI CSI output data rate = 1.5Gbps = (sensor or deserializer pixel clock in hertz) * (bits per pixel) / (number of CSI lanes)
                // 1500000000 = serdes_pix_clk_hz * csi_pixel_bit_depth / num_lanes
                // => serdes_pix_clk_hz = 1500000000 * num_lanes / csi_pixel_bit_depth
                serdes_pix_clk_hz = "187500000";

                gain_factor = "5";
                min_gain_val = "0";                         /* dB */
                max_gain_val = "300";                       /* dB */
                step_gain_val = "1";                        /* 0.3 */
                default_gain = "0";
                min_hdr_ratio = "1";
                max_hdr_ratio = "1";
                framerate_factor = "1000000";
                min_framerate = "0";
                max_framerate = "40954095";
                step_framerate = "1";
                default_framerate = "0";
                exposure_factor = "1000000";
                min_exp_time = "0";                         /* us 1 line */
                max_exp_time = "40954095";
                step_exp_time = "1";
                default_exp_time = "0";                 /* us */
                embedded_metadata_height = "0";
            };

            ports {
                #address-cells = <1>;
                #size-cells = <0>;
                port@0 {
                    reg = <0>;
                    imx490_out6: endpoint {
                        vc-id = <0>;
                        port-index = <6>;
                        bus-width = <2>;
                        remote-endpoint = <&csi_in6>;
                    };
                };
            };
            gmsl-link {
                src-csi-port = "b";
                dst-csi-port = "a";
                serdes-csi-link = "a";
                csi-mode = "1x4";
                st-vc = <0>;
                vc-id = <0>;
                num-lanes = <2>;
                streams = "ued-u1","yuv8";
            };
        };
      };
    };

    /* VI settings */

    fragment@4 {
      target = <&capture_vi_base>;
      __overlay__ {
        status = "okay";
        num-channels = <8>;
      };
    };

    fragment@5 {
      target = <&vi>;
      __overlay__ {
        status = "okay";
      };
    };

    fragment@6 {
      target = <&vi_in0>;
      __overlay__ {
        status = "okay";
        vc-id = <0>;
        port-index = <0>;
        bus-width = <2>;
        remote-endpoint = <&csi_out0>;
      };
    };

    fragment@7 {
      target = <&vi_in1>;
      __overlay__ {
        status = "okay";
        vc-id = <1>;
        port-index = <0>;
        bus-width = <2>;
        remote-endpoint = <&csi_out1>;
      };
    };

    fragment@8 {
      target = <&vi_in2>;
      __overlay__ {
        status = "okay";
        vc-id = <0>;
        port-index = <2>;
        bus-width = <2>;
        remote-endpoint = <&csi_out2>;
      };
    };

    fragment@9 {
      target = <&vi_in3>;
      __overlay__ {
        status = "okay";
        vc-id = <1>;
        port-index = <2>;
        bus-width = <2>;
        remote-endpoint = <&csi_out3>;
      };
    };

    fragment@10 {
      target = <&vi_in4>;
      __overlay__ {
        status = "okay";
        vc-id = <0>;
        port-index = <4>;
        bus-width = <2>;
        remote-endpoint = <&csi_out4>;
      };
    };

    fragment@11 {
      target = <&vi_in5>;
      __overlay__ {
        status = "okay";
        vc-id = <1>;
        port-index = <4>;
        bus-width = <2>;
        remote-endpoint = <&csi_out5>;
      };
    };

    fragment@12 {
      target = <&vi_in6>;
      __overlay__ {
        status = "okay";
        vc-id = <0>;
        port-index = <5>; // For the last VI, stream_id=5
        bus-width = <2>;
        remote-endpoint = <&csi_out6>;
      };
    };

    fragment@13 {
      target = <&vi_in7>;
      __overlay__ {
        status = "okay";
        vc-id = <1>;
        port-index = <5>; // For the last VI, stream_id=5
        bus-width = <2>;
        remote-endpoint = <&csi_out7>;
      };
    };

    /* nvcsi device tree overlay settings */

    fragment@14 {
      target = <&csi_base>;
      __overlay__ {
        status = "okay";
      };
    };

    fragment@15 {
      target = <&csi_in0>;
      __overlay__ {
        status = "okay";
        port-index = <0>;
        bus-width = <2>;
        remote-endpoint = <&imx490_out0>;
      };
    };

    fragment@16 {
      target = <&csi_in1>;
      __overlay__ {
        status = "okay";
        port-index = <0>;
        bus-width = <2>;
        remote-endpoint = <&imx490_out1>;
      };
    };

    fragment@17 {
      target = <&csi_in2>;
      __overlay__ {
        status = "okay";
        port-index = <2>;
        bus-width = <2>;
        remote-endpoint = <&imx490_out2>;
      };
    };

    fragment@18 {
      target = <&csi_in3>;
      __overlay__ {
        status = "okay";
        port-index = <2>;
        bus-width = <2>;
        remote-endpoint = <&imx490_out3>;
      };
    };

    fragment@19 {
      target = <&csi_in4>;
      __overlay__ {
        status = "okay";
        port-index = <4>;
        bus-width = <2>;
        remote-endpoint = <&imx490_out4>;
      };
    };

    fragment@20 {
      target = <&csi_in5>;
      __overlay__ {
        status = "okay";
        port-index = <4>;
        bus-width = <2>;
        remote-endpoint = <&imx490_out5>;
      };
    };

    fragment@21 {
      target = <&csi_in6>;
      __overlay__ {
        status = "okay";
        port-index = <6>;
        bus-width = <2>;
        remote-endpoint = <&imx490_out6>;
      };
    };

    fragment@22 {
      target = <&csi_in7>;
      __overlay__ {
        status = "okay";
        port-index = <6>;
        bus-width = <2>;
        remote-endpoint = <&imx490_out7>;
      };
    };

    /* Tegra Camera models */

    fragment@23 {
      target = <&camera_platform_base>;
      __overlay__ {
        status = "okay";
        num_csi_lanes = <16>;
        max_lane_speed = <2500000>;
        min_bits_per_pixel = <16>;
      };
    };

    fragment@24 {
      target = <&camera_module0>;
      __overlay__ {
        status = "okay";
        badge = "imx490_rear_liimx490";
        position = "rear";
        orientation = "1";
        drivernode0 {
          status = "okay";
          pcl_id = "v4l2_sensor";
          devname = "imx490 30-002b";
          proc-device-tree = "/proc/device-tree/i2c@c240000/tca9546@70/i2c@0/imx490_a@2b";
        };
      };
    };

    fragment@25 {
      target = <&camera_module1>;
      __overlay__ {
        status = "okay";
        badge = "imx490_front_liimx490";
        position = "front";
        orientation = "1";
        drivernode0 {
          status = "okay";
          pcl_id = "v4l2_sensor";
          devname = "imx490 30-002c";
          proc-device-tree = "/proc/device-tree/i2c@c240000/tca9546@70/i2c@0/imx490_b@2c";
        };
      };
    };

    fragment@26 {
      target = <&camera_module2>;
      __overlay__ {
        status = "okay";
        badge = "imx490_topright_liimx490";
        position = "topright";
        orientation = "1";
        drivernode0 {
          status = "okay";
          pcl_id = "v4l2_sensor";
          devname = "imx490 31-002b";
          proc-device-tree = "/proc/device-tree/i2c@c240000/tca9546@70/i2c@1/imx490_c@2b";
        };
      };
    };

    fragment@27 {
      target = <&camera_module3>;
      __overlay__ {
        status = "okay";
        badge = "imx490_bottomright_liimx490";
        position = "bottomright";
        orientation = "1";
        drivernode0 {
          status = "okay";
          pcl_id = "v4l2_sensor";
          devname = "imx490 31-002c";
          proc-device-tree = "/proc/device-tree/i2c@c240000/tca9546@70/i2c@1/imx490_d@2c";
        };
      };
    };

    fragment@28 {
      target = <&camera_module4>;
      __overlay__ {
        status = "okay";
        badge = "imx490_topleft_liimx490";
        position = "topleft";
        orientation = "1";
        drivernode0 {
          status = "okay";
          pcl_id = "v4l2_sensor";
          devname = "imx490 32-002b";
          proc-device-tree = "/proc/device-tree/i2c@c240000/tca9546@70/i2c@2/imx490_e@2b";
        };
      };
    };

    fragment@29 {
      target = <&camera_module5>;
      __overlay__ {
        status = "okay";
        badge = "imx490_centerright_liimx490";
        position = "centerright";
        orientation = "1";
        drivernode0 {
          status = "okay";
          pcl_id = "v4l2_sensor";
          devname = "imx490 32-002c";
          proc-device-tree = "/proc/device-tree/i2c@c240000/tca9546@70/i2c@2/imx490_f@2c";
        };
      };
    };

    fragment@30 {
      target = <&camera_module6>;
      __overlay__ {
        status = "okay";
        badge = "imx490_centerleft_liimx490";
        position = "centerleft";
        orientation = "1";
        drivernode0 {
          status = "okay";
          pcl_id = "v4l2_sensor";
          devname = "imx490 33-002b";
          proc-device-tree = "/proc/device-tree/i2c@c240000/tca9546@70/i2c@3/imx490_g@2b";
        };
      };
    };

    fragment@31 {
      target = <&camera_module7>;
      __overlay__ {
        status = "okay";
        badge = "imx490_bottomleft_liimx490";
        position = "bottomleft";
        orientation = "1";
        drivernode0 {
          status = "okay";
          pcl_id = "v4l2_sensor";
          devname = "imx490 33-002c";
          proc-device-tree = "/proc/device-tree/i2c@c240000/tca9546@70/i2c@3/imx490_h@2c";
        };
      };
    };

/* Deserializers */

    fragment@32 {
      target = <&dser_0>;
      __overlay__ {
        status = "okay";
        compatible = "nvidia,tier4_max9296";
      };
    };

    fragment@33 {
      target = <&dser_1>;
      __overlay__ {
        status = "okay";
        compatible = "nvidia,tier4_max9296";
      };
    };

    fragment@34 {
      target = <&dser_2>;
      __overlay__ {
        status = "okay";
        compatible = "nvidia,tier4_max9296";
      };
    };

    fragment@35 {
      target = <&dser_3>;
      __overlay__ {
        status = "okay";
        compatible = "nvidia,tier4_max9296";
      };
    };

/* FPGA */

    fragment@36 {
      target-path = "/i2c@3180000";
      __overlay__ {
       t4_fpga: tier4_fpga@66 {
          compatible = "nvidia,tier4_fpga";
          reg = <0x66>;
          generate-fsync = "false";
          status = "okay";
        };
      };
    };

};